{"ast":null,"code":"define([\"./core\", \"./core/nodeName\", \"./core/camelCase\", \"./core/toType\", \"./var/isFunction\", \"./var/isWindow\", \"./var/slice\", \"./event/alias\"], function (jQuery, nodeName, camelCase, toType, isFunction, isWindow, slice) {\n  \"use strict\";\n\n  jQuery.fn.extend({\n    bind: function (types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function (types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function (selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function (selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    }\n  }); // Bind a function to a context, optionally partially applying any\n  // arguments.\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n  // However, it is not slated for removal any time soon\n\n  jQuery.proxy = function (fn, context) {\n    var tmp, args, proxy;\n\n    if (typeof context === \"string\") {\n      tmp = fn[context];\n      context = fn;\n      fn = tmp;\n    } // Quick check to determine if target is callable, in the spec\n    // this throws a TypeError, but we will just return undefined.\n\n\n    if (!isFunction(fn)) {\n      return undefined;\n    } // Simulated bind\n\n\n    args = slice.call(arguments, 2);\n\n    proxy = function () {\n      return fn.apply(context || this, args.concat(slice.call(arguments)));\n    }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n    return proxy;\n  };\n\n  jQuery.holdReady = function (hold) {\n    if (hold) {\n      jQuery.readyWait++;\n    } else {\n      jQuery.ready(true);\n    }\n  };\n\n  jQuery.isArray = Array.isArray;\n  jQuery.parseJSON = JSON.parse;\n  jQuery.nodeName = nodeName;\n  jQuery.isFunction = isFunction;\n  jQuery.isWindow = isWindow;\n  jQuery.camelCase = camelCase;\n  jQuery.type = toType;\n  jQuery.now = Date.now;\n\n  jQuery.isNumeric = function (obj) {\n    // As of jQuery 3.0, isNumeric is limited to\n    // strings and numbers (primitives or objects)\n    // that can be coerced to finite numbers (gh-2662)\n    var type = jQuery.type(obj);\n    return (type === \"number\" || type === \"string\") && // parseFloat NaNs numeric-cast false positives (\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    !isNaN(obj - parseFloat(obj));\n  };\n});","map":{"version":3,"sources":["/home/master/ProjectBootstrap/test_task/src/bower_components/jquery/src/deprecated.js"],"names":["define","jQuery","nodeName","camelCase","toType","isFunction","isWindow","slice","fn","extend","bind","types","data","on","unbind","off","delegate","selector","undelegate","arguments","length","proxy","context","tmp","args","undefined","call","apply","concat","guid","holdReady","hold","readyWait","ready","isArray","Array","parseJSON","JSON","parse","type","now","Date","isNumeric","obj","isNaN","parseFloat"],"mappings":"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","sourcesContent":["define( [\n\t\"./core\",\n\t\"./core/nodeName\",\n\t\"./core/camelCase\",\n\t\"./core/toType\",\n\t\"./var/isFunction\",\n\t\"./var/isWindow\",\n\t\"./var/slice\",\n\n\t\"./event/alias\"\n], function( jQuery, nodeName, camelCase, toType, isFunction, isWindow, slice ) {\n\n\"use strict\";\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n} );\n"]},"metadata":{},"sourceType":"module"}