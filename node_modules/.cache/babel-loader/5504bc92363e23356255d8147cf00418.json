{"ast":null,"code":"/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function (window) {\n  var i,\n      support,\n      Expr,\n      getText,\n      isXML,\n      tokenize,\n      compile,\n      select,\n      outermostContext,\n      sortInput,\n      hasDuplicate,\n      // Local document vars\n  setDocument,\n      document,\n      docElem,\n      documentIsHTML,\n      rbuggyQSA,\n      rbuggyMatches,\n      matches,\n      contains,\n      // Instance-specific data\n  expando = \"sizzle\" + 1 * new Date(),\n      preferredDoc = window.document,\n      dirruns = 0,\n      done = 0,\n      classCache = createCache(),\n      tokenCache = createCache(),\n      compilerCache = createCache(),\n      sortOrder = function (a, b) {\n    if (a === b) {\n      hasDuplicate = true;\n    }\n\n    return 0;\n  },\n      // Instance methods\n  hasOwn = {}.hasOwnProperty,\n      arr = [],\n      pop = arr.pop,\n      push_native = arr.push,\n      push = arr.push,\n      slice = arr.slice,\n      // Use a stripped-down indexOf as it's faster than native\n  // https://jsperf.com/thor-indexof-vs-for/5\n  indexOf = function (list, elem) {\n    var i = 0,\n        len = list.length;\n\n    for (; i < len; i++) {\n      if (list[i] === elem) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n      booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n      // Regular expressions\n  // http://www.w3.org/TR/css3-selectors/#whitespace\n  whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n      // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n  identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n      // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n  attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n  \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n  \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n      pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n  // 1. quoted (capture 3; capture 4 or capture 5)\n  \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n  \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n  \".*\" + \")\\\\)|)\",\n      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n  rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n      rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n      rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n      rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n      rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"),\n      rpseudo = new RegExp(pseudos),\n      ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n      matchExpr = {\n    \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n    \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n    \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n    \"ATTR\": new RegExp(\"^\" + attributes),\n    \"PSEUDO\": new RegExp(\"^\" + pseudos),\n    \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n    \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n    // For use in libraries implementing .is()\n    // We use this for POS matching in `select`\n    \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n  },\n      rinputs = /^(?:input|select|textarea|button)$/i,\n      rheader = /^h\\d$/i,\n      rnative = /^[^{]+\\{\\s*\\[native \\w/,\n      // Easily-parseable/retrievable ID or TAG or CLASS selectors\n  rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n      rsibling = /[+~]/,\n      // CSS escapes\n  // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n  runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n      funescape = function (_, escaped, escapedWhitespace) {\n    var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n    // Support: Firefox<24\n    // Workaround erroneous numeric interpretation of +\"0x\"\n\n    return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n    String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n    String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n  },\n      // CSS string/identifier serialization\n  // https://drafts.csswg.org/cssom/#common-serializing-idioms\n  rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n      fcssescape = function (ch, asCodePoint) {\n    if (asCodePoint) {\n      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n      if (ch === \"\\0\") {\n        return \"\\uFFFD\";\n      } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n      return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n    } // Other potentially-special ASCII characters get backslash-escaped\n\n\n    return \"\\\\\" + ch;\n  },\n      // Used for iframes\n  // See setDocument()\n  // Removing the function wrapper causes a \"Permission Denied\"\n  // error in IE\n  unloadHandler = function () {\n    setDocument();\n  },\n      disabledAncestor = addCombinator(function (elem) {\n    return elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n  }, {\n    dir: \"parentNode\",\n    next: \"legend\"\n  }); // Optimize for push.apply( _, NodeList )\n\n\n  try {\n    push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n    // Detect silently failing push.apply\n\n    arr[preferredDoc.childNodes.length].nodeType;\n  } catch (e) {\n    push = {\n      apply: arr.length ? // Leverage slice if possible\n      function (target, els) {\n        push_native.apply(target, slice.call(els));\n      } : // Support: IE<9\n      // Otherwise append directly\n      function (target, els) {\n        var j = target.length,\n            i = 0; // Can't trust NodeList.length\n\n        while (target[j++] = els[i++]) {}\n\n        target.length = j - 1;\n      }\n    };\n  }\n\n  function Sizzle(selector, context, results, seed) {\n    var m,\n        i,\n        elem,\n        nid,\n        match,\n        groups,\n        newSelector,\n        newContext = context && context.ownerDocument,\n        // nodeType defaults to 9, since context defaults to document\n    nodeType = context ? context.nodeType : 9;\n    results = results || []; // Return early from calls with invalid selector or context\n\n    if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n      return results;\n    } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n    if (!seed) {\n      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n        setDocument(context);\n      }\n\n      context = context || document;\n\n      if (documentIsHTML) {\n        // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n        // (excepting DocumentFragment context, where the methods don't exist)\n        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n          // ID selector\n          if (m = match[1]) {\n            // Document context\n            if (nodeType === 9) {\n              if (elem = context.getElementById(m)) {\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } else {\n                return results;\n              } // Element context\n\n            } else {\n              // Support: IE, Opera, Webkit\n              // TODO: identify versions\n              // getElementById can match elements by name instead of ID\n              if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                results.push(elem);\n                return results;\n              }\n            } // Type selector\n\n          } else if (match[2]) {\n            push.apply(results, context.getElementsByTagName(selector));\n            return results; // Class selector\n          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n            push.apply(results, context.getElementsByClassName(m));\n            return results;\n          }\n        } // Take advantage of querySelectorAll\n\n\n        if (support.qsa && !compilerCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n          if (nodeType !== 1) {\n            newContext = context;\n            newSelector = selector; // qSA looks outside Element context, which is not what we want\n            // Thanks to Andrew Dupont for this workaround technique\n            // Support: IE <=8\n            // Exclude object elements\n          } else if (context.nodeName.toLowerCase() !== \"object\") {\n            // Capture the context ID, setting it first if necessary\n            if (nid = context.getAttribute(\"id\")) {\n              nid = nid.replace(rcssescape, fcssescape);\n            } else {\n              context.setAttribute(\"id\", nid = expando);\n            } // Prefix every selector in the list\n\n\n            groups = tokenize(selector);\n            i = groups.length;\n\n            while (i--) {\n              groups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\n            }\n\n            newSelector = groups.join(\",\"); // Expand context for sibling selectors\n\n            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n          }\n\n          if (newSelector) {\n            try {\n              push.apply(results, newContext.querySelectorAll(newSelector));\n              return results;\n            } catch (qsaError) {} finally {\n              if (nid === expando) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      }\n    } // All others\n\n\n    return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n  }\n  /**\n   * Create key-value caches of limited size\n   * @returns {function(string, object)} Returns the Object data after storing it on itself with\n   *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n   *\tdeleting the oldest entry\n   */\n\n\n  function createCache() {\n    var keys = [];\n\n    function cache(key, value) {\n      // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n      if (keys.push(key + \" \") > Expr.cacheLength) {\n        // Only keep the most recent entries\n        delete cache[keys.shift()];\n      }\n\n      return cache[key + \" \"] = value;\n    }\n\n    return cache;\n  }\n  /**\n   * Mark a function for special use by Sizzle\n   * @param {Function} fn The function to mark\n   */\n\n\n  function markFunction(fn) {\n    fn[expando] = true;\n    return fn;\n  }\n  /**\n   * Support testing using an element\n   * @param {Function} fn Passed the created element and returns a boolean result\n   */\n\n\n  function assert(fn) {\n    var el = document.createElement(\"fieldset\");\n\n    try {\n      return !!fn(el);\n    } catch (e) {\n      return false;\n    } finally {\n      // Remove from its parent by default\n      if (el.parentNode) {\n        el.parentNode.removeChild(el);\n      } // release memory in IE\n\n\n      el = null;\n    }\n  }\n  /**\n   * Adds the same handler for all of the specified attrs\n   * @param {String} attrs Pipe-separated list of attributes\n   * @param {Function} handler The method that will be applied\n   */\n\n\n  function addHandle(attrs, handler) {\n    var arr = attrs.split(\"|\"),\n        i = arr.length;\n\n    while (i--) {\n      Expr.attrHandle[arr[i]] = handler;\n    }\n  }\n  /**\n   * Checks document order of two siblings\n   * @param {Element} a\n   * @param {Element} b\n   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n   */\n\n\n  function siblingCheck(a, b) {\n    var cur = b && a,\n        diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n    if (diff) {\n      return diff;\n    } // Check if b follows a\n\n\n    if (cur) {\n      while (cur = cur.nextSibling) {\n        if (cur === b) {\n          return -1;\n        }\n      }\n    }\n\n    return a ? 1 : -1;\n  }\n  /**\n   * Returns a function to use in pseudos for input types\n   * @param {String} type\n   */\n\n\n  function createInputPseudo(type) {\n    return function (elem) {\n      var name = elem.nodeName.toLowerCase();\n      return name === \"input\" && elem.type === type;\n    };\n  }\n  /**\n   * Returns a function to use in pseudos for buttons\n   * @param {String} type\n   */\n\n\n  function createButtonPseudo(type) {\n    return function (elem) {\n      var name = elem.nodeName.toLowerCase();\n      return (name === \"input\" || name === \"button\") && elem.type === type;\n    };\n  }\n  /**\n   * Returns a function to use in pseudos for :enabled/:disabled\n   * @param {Boolean} disabled true for :disabled; false for :enabled\n   */\n\n\n  function createDisabledPseudo(disabled) {\n    // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n    return function (elem) {\n      // Only certain elements can match :enabled or :disabled\n      // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n      // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n      if (\"form\" in elem) {\n        // Check for inherited disabledness on relevant non-disabled elements:\n        // * listed form-associated elements in a disabled fieldset\n        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n        // * option elements in a disabled optgroup\n        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n        // All such elements have a \"form\" property.\n        if (elem.parentNode && elem.disabled === false) {\n          // Option elements defer to a parent optgroup if present\n          if (\"label\" in elem) {\n            if (\"label\" in elem.parentNode) {\n              return elem.parentNode.disabled === disabled;\n            } else {\n              return elem.disabled === disabled;\n            }\n          } // Support: IE 6 - 11\n          // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n          return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n          /* jshint -W018 */\n          elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;\n        }\n\n        return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n        // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n        // even exist on them, let alone have a boolean value.\n      } else if (\"label\" in elem) {\n        return elem.disabled === disabled;\n      } // Remaining elements are neither :enabled nor :disabled\n\n\n      return false;\n    };\n  }\n  /**\n   * Returns a function to use in pseudos for positionals\n   * @param {Function} fn\n   */\n\n\n  function createPositionalPseudo(fn) {\n    return markFunction(function (argument) {\n      argument = +argument;\n      return markFunction(function (seed, matches) {\n        var j,\n            matchIndexes = fn([], seed.length, argument),\n            i = matchIndexes.length; // Match elements found at the specified indexes\n\n        while (i--) {\n          if (seed[j = matchIndexes[i]]) {\n            seed[j] = !(matches[j] = seed[j]);\n          }\n        }\n      });\n    });\n  }\n  /**\n   * Checks a node for validity as a Sizzle context\n   * @param {Element|Object=} context\n   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n   */\n\n\n  function testContext(context) {\n    return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n  } // Expose support vars for convenience\n\n\n  support = Sizzle.support = {};\n  /**\n   * Detects XML nodes\n   * @param {Element|Object} elem An element or a document\n   * @returns {Boolean} True iff elem is a non-HTML XML node\n   */\n\n  isXML = Sizzle.isXML = function (elem) {\n    // documentElement is verified for cases where it doesn't yet exist\n    // (such as loading iframes in IE - #4833)\n    var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n    return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n  };\n  /**\n   * Sets document-related variables once based on the current document\n   * @param {Element|Object} [doc] An element or document object to use to set the document\n   * @returns {Object} Returns the current document\n   */\n\n\n  setDocument = Sizzle.setDocument = function (node) {\n    var hasCompare,\n        subWindow,\n        doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n\n    if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n      return document;\n    } // Update global variables\n\n\n    document = doc;\n    docElem = document.documentElement;\n    documentIsHTML = !isXML(document); // Support: IE 9-11, Edge\n    // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\n    if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n      // Support: IE 11, Edge\n      if (subWindow.addEventListener) {\n        subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n      } else if (subWindow.attachEvent) {\n        subWindow.attachEvent(\"onunload\", unloadHandler);\n      }\n    }\n    /* Attributes\n    ---------------------------------------------------------------------- */\n    // Support: IE<8\n    // Verify that getAttribute really returns attributes and not properties\n    // (excepting IE8 booleans)\n\n\n    support.attributes = assert(function (el) {\n      el.className = \"i\";\n      return !el.getAttribute(\"className\");\n    });\n    /* getElement(s)By*\n    ---------------------------------------------------------------------- */\n    // Check if getElementsByTagName(\"*\") returns only elements\n\n    support.getElementsByTagName = assert(function (el) {\n      el.appendChild(document.createComment(\"\"));\n      return !el.getElementsByTagName(\"*\").length;\n    }); // Support: IE<9\n\n    support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n    // Check if getElementById returns elements by name\n    // The broken getElementById methods don't pick up programmatically-set names,\n    // so use a roundabout getElementsByName test\n\n    support.getById = assert(function (el) {\n      docElem.appendChild(el).id = expando;\n      return !document.getElementsByName || !document.getElementsByName(expando).length;\n    }); // ID filter and find\n\n    if (support.getById) {\n      Expr.filter[\"ID\"] = function (id) {\n        var attrId = id.replace(runescape, funescape);\n        return function (elem) {\n          return elem.getAttribute(\"id\") === attrId;\n        };\n      };\n\n      Expr.find[\"ID\"] = function (id, context) {\n        if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n          var elem = context.getElementById(id);\n          return elem ? [elem] : [];\n        }\n      };\n    } else {\n      Expr.filter[\"ID\"] = function (id) {\n        var attrId = id.replace(runescape, funescape);\n        return function (elem) {\n          var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n          return node && node.value === attrId;\n        };\n      }; // Support: IE 6 - 7 only\n      // getElementById is not reliable as a find shortcut\n\n\n      Expr.find[\"ID\"] = function (id, context) {\n        if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n          var node,\n              i,\n              elems,\n              elem = context.getElementById(id);\n\n          if (elem) {\n            // Verify the id attribute\n            node = elem.getAttributeNode(\"id\");\n\n            if (node && node.value === id) {\n              return [elem];\n            } // Fall back on getElementsByName\n\n\n            elems = context.getElementsByName(id);\n            i = 0;\n\n            while (elem = elems[i++]) {\n              node = elem.getAttributeNode(\"id\");\n\n              if (node && node.value === id) {\n                return [elem];\n              }\n            }\n          }\n\n          return [];\n        }\n      };\n    } // Tag\n\n\n    Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n      if (typeof context.getElementsByTagName !== \"undefined\") {\n        return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n      } else if (support.qsa) {\n        return context.querySelectorAll(tag);\n      }\n    } : function (tag, context) {\n      var elem,\n          tmp = [],\n          i = 0,\n          // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n      results = context.getElementsByTagName(tag); // Filter out possible comments\n\n      if (tag === \"*\") {\n        while (elem = results[i++]) {\n          if (elem.nodeType === 1) {\n            tmp.push(elem);\n          }\n        }\n\n        return tmp;\n      }\n\n      return results;\n    }; // Class\n\n    Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n      if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n        return context.getElementsByClassName(className);\n      }\n    };\n    /* QSA/matchesSelector\n    ---------------------------------------------------------------------- */\n    // QSA and matchesSelector support\n    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n    rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n    // We allow this because of a bug in IE8/9 that throws an error\n    // whenever `document.activeElement` is accessed on an iframe\n    // So, we allow :focus to pass through QSA all the time to avoid the IE error\n    // See https://bugs.jquery.com/ticket/13378\n\n    rbuggyQSA = [];\n\n    if (support.qsa = rnative.test(document.querySelectorAll)) {\n      // Build QSA regex\n      // Regex strategy adopted from Diego Perini\n      assert(function (el) {\n        // Select is set to empty string on purpose\n        // This is to test IE's treatment of not explicitly\n        // setting a boolean content attribute,\n        // since its presence should be enough\n        // https://bugs.jquery.com/ticket/12359\n        docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n        // Nothing should be selected when empty strings follow ^= or $= or *=\n        // The test attribute must be unknown in Opera but \"safe\" for WinRT\n        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n        if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n          rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n        } // Support: IE8\n        // Boolean attributes and \"value\" are not treated correctly\n\n\n        if (!el.querySelectorAll(\"[selected]\").length) {\n          rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n        } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n        if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n          rbuggyQSA.push(\"~=\");\n        } // Webkit/Opera - :checked should return selected option elements\n        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n        // IE8 throws error here and will not see later tests\n\n\n        if (!el.querySelectorAll(\":checked\").length) {\n          rbuggyQSA.push(\":checked\");\n        } // Support: Safari 8+, iOS 8+\n        // https://bugs.webkit.org/show_bug.cgi?id=136851\n        // In-page `selector#id sibling-combinator selector` fails\n\n\n        if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n          rbuggyQSA.push(\".#.+[+~]\");\n        }\n      });\n      assert(function (el) {\n        el.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"; // Support: Windows 8 Native Apps\n        // The type and name attributes are restricted during .innerHTML assignment\n\n        var input = document.createElement(\"input\");\n        input.setAttribute(\"type\", \"hidden\");\n        el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n        // Enforce case-sensitivity of name attribute\n\n        if (el.querySelectorAll(\"[name=d]\").length) {\n          rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n        } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n        // IE8 throws error here and will not see later tests\n\n\n        if (el.querySelectorAll(\":enabled\").length !== 2) {\n          rbuggyQSA.push(\":enabled\", \":disabled\");\n        } // Support: IE9-11+\n        // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n        docElem.appendChild(el).disabled = true;\n\n        if (el.querySelectorAll(\":disabled\").length !== 2) {\n          rbuggyQSA.push(\":enabled\", \":disabled\");\n        } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n        el.querySelectorAll(\"*,:x\");\n        rbuggyQSA.push(\",.*:\");\n      });\n    }\n\n    if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n      assert(function (el) {\n        // Check to see if it's possible to do matchesSelector\n        // on a disconnected node (IE 9)\n        support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n        // Gecko does not error, returns false instead\n\n        matches.call(el, \"[s!='']:x\");\n        rbuggyMatches.push(\"!=\", pseudos);\n      });\n    }\n\n    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n    /* Contains\n    ---------------------------------------------------------------------- */\n\n    hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n    // Purposefully self-exclusive\n    // As in, an element does not contain itself\n\n    contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n      var adown = a.nodeType === 9 ? a.documentElement : a,\n          bup = b && b.parentNode;\n      return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n    } : function (a, b) {\n      if (b) {\n        while (b = b.parentNode) {\n          if (b === a) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n    /* Sorting\n    ---------------------------------------------------------------------- */\n    // Document order sorting\n\n    sortOrder = hasCompare ? function (a, b) {\n      // Flag for duplicate removal\n      if (a === b) {\n        hasDuplicate = true;\n        return 0;\n      } // Sort on method existence if only one input has compareDocumentPosition\n\n\n      var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n      if (compare) {\n        return compare;\n      } // Calculate position if both inputs belong to the same document\n\n\n      compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n      1; // Disconnected nodes\n\n      if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n        // Choose the first element that is related to our preferred document\n        if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n          return -1;\n        }\n\n        if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n          return 1;\n        } // Maintain original order\n\n\n        return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n      }\n\n      return compare & 4 ? -1 : 1;\n    } : function (a, b) {\n      // Exit early if the nodes are identical\n      if (a === b) {\n        hasDuplicate = true;\n        return 0;\n      }\n\n      var cur,\n          i = 0,\n          aup = a.parentNode,\n          bup = b.parentNode,\n          ap = [a],\n          bp = [b]; // Parentless nodes are either documents or disconnected\n\n      if (!aup || !bup) {\n        return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n      } else if (aup === bup) {\n        return siblingCheck(a, b);\n      } // Otherwise we need full lists of their ancestors for comparison\n\n\n      cur = a;\n\n      while (cur = cur.parentNode) {\n        ap.unshift(cur);\n      }\n\n      cur = b;\n\n      while (cur = cur.parentNode) {\n        bp.unshift(cur);\n      } // Walk down the tree looking for a discrepancy\n\n\n      while (ap[i] === bp[i]) {\n        i++;\n      }\n\n      return i ? // Do a sibling check if the nodes have a common ancestor\n      siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n      ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n    };\n    return document;\n  };\n\n  Sizzle.matches = function (expr, elements) {\n    return Sizzle(expr, null, null, elements);\n  };\n\n  Sizzle.matchesSelector = function (elem, expr) {\n    // Set document vars if needed\n    if ((elem.ownerDocument || elem) !== document) {\n      setDocument(elem);\n    } // Make sure that attribute selectors are quoted\n\n\n    expr = expr.replace(rattributeQuotes, \"='$1']\");\n\n    if (support.matchesSelector && documentIsHTML && !compilerCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n      try {\n        var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n        if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n        // fragment in IE 9\n        elem.document && elem.document.nodeType !== 11) {\n          return ret;\n        }\n      } catch (e) {}\n    }\n\n    return Sizzle(expr, document, null, [elem]).length > 0;\n  };\n\n  Sizzle.contains = function (context, elem) {\n    // Set document vars if needed\n    if ((context.ownerDocument || context) !== document) {\n      setDocument(context);\n    }\n\n    return contains(context, elem);\n  };\n\n  Sizzle.attr = function (elem, name) {\n    // Set document vars if needed\n    if ((elem.ownerDocument || elem) !== document) {\n      setDocument(elem);\n    }\n\n    var fn = Expr.attrHandle[name.toLowerCase()],\n        // Don't get fooled by Object.prototype properties (jQuery #13807)\n    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n    return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n  };\n\n  Sizzle.escape = function (sel) {\n    return (sel + \"\").replace(rcssescape, fcssescape);\n  };\n\n  Sizzle.error = function (msg) {\n    throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n  };\n  /**\n   * Document sorting and removing duplicates\n   * @param {ArrayLike} results\n   */\n\n\n  Sizzle.uniqueSort = function (results) {\n    var elem,\n        duplicates = [],\n        j = 0,\n        i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n    hasDuplicate = !support.detectDuplicates;\n    sortInput = !support.sortStable && results.slice(0);\n    results.sort(sortOrder);\n\n    if (hasDuplicate) {\n      while (elem = results[i++]) {\n        if (elem === results[i]) {\n          j = duplicates.push(i);\n        }\n      }\n\n      while (j--) {\n        results.splice(duplicates[j], 1);\n      }\n    } // Clear input after sorting to release objects\n    // See https://github.com/jquery/sizzle/pull/225\n\n\n    sortInput = null;\n    return results;\n  };\n  /**\n   * Utility function for retrieving the text value of an array of DOM nodes\n   * @param {Array|Element} elem\n   */\n\n\n  getText = Sizzle.getText = function (elem) {\n    var node,\n        ret = \"\",\n        i = 0,\n        nodeType = elem.nodeType;\n\n    if (!nodeType) {\n      // If no nodeType, this is expected to be an array\n      while (node = elem[i++]) {\n        // Do not traverse comment nodes\n        ret += getText(node);\n      }\n    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n      // Use textContent for elements\n      // innerText usage removed for consistency of new lines (jQuery #11153)\n      if (typeof elem.textContent === \"string\") {\n        return elem.textContent;\n      } else {\n        // Traverse its children\n        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n          ret += getText(elem);\n        }\n      }\n    } else if (nodeType === 3 || nodeType === 4) {\n      return elem.nodeValue;\n    } // Do not include comment or processing instruction nodes\n\n\n    return ret;\n  };\n\n  Expr = Sizzle.selectors = {\n    // Can be adjusted by the user\n    cacheLength: 50,\n    createPseudo: markFunction,\n    match: matchExpr,\n    attrHandle: {},\n    find: {},\n    relative: {\n      \">\": {\n        dir: \"parentNode\",\n        first: true\n      },\n      \" \": {\n        dir: \"parentNode\"\n      },\n      \"+\": {\n        dir: \"previousSibling\",\n        first: true\n      },\n      \"~\": {\n        dir: \"previousSibling\"\n      }\n    },\n    preFilter: {\n      \"ATTR\": function (match) {\n        match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n        match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n        if (match[2] === \"~=\") {\n          match[3] = \" \" + match[3] + \" \";\n        }\n\n        return match.slice(0, 4);\n      },\n      \"CHILD\": function (match) {\n        /* matches from matchExpr[\"CHILD\"]\n        \t1 type (only|nth|...)\n        \t2 what (child|of-type)\n        \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n        \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n        \t5 sign of xn-component\n        \t6 x of xn-component\n        \t7 sign of y-component\n        \t8 y of y-component\n        */\n        match[1] = match[1].toLowerCase();\n\n        if (match[1].slice(0, 3) === \"nth\") {\n          // nth-* requires argument\n          if (!match[3]) {\n            Sizzle.error(match[0]);\n          } // numeric x and y parameters for Expr.filter.CHILD\n          // remember that false/true cast respectively to 0/1\n\n\n          match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n          match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n        } else if (match[3]) {\n          Sizzle.error(match[0]);\n        }\n\n        return match;\n      },\n      \"PSEUDO\": function (match) {\n        var excess,\n            unquoted = !match[6] && match[2];\n\n        if (matchExpr[\"CHILD\"].test(match[0])) {\n          return null;\n        } // Accept quoted arguments as-is\n\n\n        if (match[3]) {\n          match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n        } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n        excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n        excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n          // excess is a negative index\n          match[0] = match[0].slice(0, excess);\n          match[2] = unquoted.slice(0, excess);\n        } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n        return match.slice(0, 3);\n      }\n    },\n    filter: {\n      \"TAG\": function (nodeNameSelector) {\n        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n        return nodeNameSelector === \"*\" ? function () {\n          return true;\n        } : function (elem) {\n          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n        };\n      },\n      \"CLASS\": function (className) {\n        var pattern = classCache[className + \" \"];\n        return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n          return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n        });\n      },\n      \"ATTR\": function (name, operator, check) {\n        return function (elem) {\n          var result = Sizzle.attr(elem, name);\n\n          if (result == null) {\n            return operator === \"!=\";\n          }\n\n          if (!operator) {\n            return true;\n          }\n\n          result += \"\";\n          return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n        };\n      },\n      \"CHILD\": function (type, what, argument, first, last) {\n        var simple = type.slice(0, 3) !== \"nth\",\n            forward = type.slice(-4) !== \"last\",\n            ofType = what === \"of-type\";\n        return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n        function (elem) {\n          return !!elem.parentNode;\n        } : function (elem, context, xml) {\n          var cache,\n              uniqueCache,\n              outerCache,\n              node,\n              nodeIndex,\n              start,\n              dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n              parent = elem.parentNode,\n              name = ofType && elem.nodeName.toLowerCase(),\n              useCache = !xml && !ofType,\n              diff = false;\n\n          if (parent) {\n            // :(first|last|only)-(child|of-type)\n            if (simple) {\n              while (dir) {\n                node = elem;\n\n                while (node = node[dir]) {\n                  if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                    return false;\n                  }\n                } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                start = dir = type === \"only\" && !start && \"nextSibling\";\n              }\n\n              return true;\n            }\n\n            start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n            if (forward && useCache) {\n              // Seek `elem` from a previously-cached index\n              // ...in a gzip-friendly way\n              node = parent;\n              outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n\n              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n              cache = uniqueCache[type] || [];\n              nodeIndex = cache[0] === dirruns && cache[1];\n              diff = nodeIndex && cache[2];\n              node = nodeIndex && parent.childNodes[nodeIndex];\n\n              while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n              diff = nodeIndex = 0) || start.pop()) {\n                // When found, cache indexes on `parent` and break\n                if (node.nodeType === 1 && ++diff && node === elem) {\n                  uniqueCache[type] = [dirruns, nodeIndex, diff];\n                  break;\n                }\n              }\n            } else {\n              // Use previously-cached element index if available\n              if (useCache) {\n                // ...in a gzip-friendly way\n                node = elem;\n                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex;\n              } // xml :nth-child(...)\n              // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n              if (diff === false) {\n                // Use the same loop as above to seek `elem` from the start\n                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                    // Cache the index of each encountered element\n                    if (useCache) {\n                      outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                      // Defend against cloned attroperties (jQuery gh-1709)\n\n                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                      uniqueCache[type] = [dirruns, diff];\n                    }\n\n                    if (node === elem) {\n                      break;\n                    }\n                  }\n                }\n              }\n            } // Incorporate the offset, then check against cycle size\n\n\n            diff -= last;\n            return diff === first || diff % first === 0 && diff / first >= 0;\n          }\n        };\n      },\n      \"PSEUDO\": function (pseudo, argument) {\n        // pseudo-class names are case-insensitive\n        // http://www.w3.org/TR/selectors/#pseudo-classes\n        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n        // Remember that setFilters inherits from pseudos\n        var args,\n            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n        // arguments are needed to create the filter function\n        // just as Sizzle does\n\n        if (fn[expando]) {\n          return fn(argument);\n        } // But maintain support for old signatures\n\n\n        if (fn.length > 1) {\n          args = [pseudo, pseudo, \"\", argument];\n          return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n            var idx,\n                matched = fn(seed, argument),\n                i = matched.length;\n\n            while (i--) {\n              idx = indexOf(seed, matched[i]);\n              seed[idx] = !(matches[idx] = matched[i]);\n            }\n          }) : function (elem) {\n            return fn(elem, 0, args);\n          };\n        }\n\n        return fn;\n      }\n    },\n    pseudos: {\n      // Potentially complex pseudos\n      \"not\": markFunction(function (selector) {\n        // Trim the selector passed to compile\n        // to avoid treating leading and trailing\n        // spaces as combinators\n        var input = [],\n            results = [],\n            matcher = compile(selector.replace(rtrim, \"$1\"));\n        return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n          var elem,\n              unmatched = matcher(seed, null, xml, []),\n              i = seed.length; // Match elements unmatched by `matcher`\n\n          while (i--) {\n            if (elem = unmatched[i]) {\n              seed[i] = !(matches[i] = elem);\n            }\n          }\n        }) : function (elem, context, xml) {\n          input[0] = elem;\n          matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n          input[0] = null;\n          return !results.pop();\n        };\n      }),\n      \"has\": markFunction(function (selector) {\n        return function (elem) {\n          return Sizzle(selector, elem).length > 0;\n        };\n      }),\n      \"contains\": markFunction(function (text) {\n        text = text.replace(runescape, funescape);\n        return function (elem) {\n          return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n        };\n      }),\n      // \"Whether an element is represented by a :lang() selector\n      // is based solely on the element's language value\n      // being equal to the identifier C,\n      // or beginning with the identifier C immediately followed by \"-\".\n      // The matching of C against the element's language value is performed case-insensitively.\n      // The identifier C does not have to be a valid language name.\"\n      // http://www.w3.org/TR/selectors/#lang-pseudo\n      \"lang\": markFunction(function (lang) {\n        // lang value must be a valid identifier\n        if (!ridentifier.test(lang || \"\")) {\n          Sizzle.error(\"unsupported lang: \" + lang);\n        }\n\n        lang = lang.replace(runescape, funescape).toLowerCase();\n        return function (elem) {\n          var elemLang;\n\n          do {\n            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n              elemLang = elemLang.toLowerCase();\n              return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n            }\n          } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n          return false;\n        };\n      }),\n      // Miscellaneous\n      \"target\": function (elem) {\n        var hash = window.location && window.location.hash;\n        return hash && hash.slice(1) === elem.id;\n      },\n      \"root\": function (elem) {\n        return elem === docElem;\n      },\n      \"focus\": function (elem) {\n        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n      },\n      // Boolean properties\n      \"enabled\": createDisabledPseudo(false),\n      \"disabled\": createDisabledPseudo(true),\n      \"checked\": function (elem) {\n        // In CSS3, :checked should return both checked and selected elements\n        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n        var nodeName = elem.nodeName.toLowerCase();\n        return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n      },\n      \"selected\": function (elem) {\n        // Accessing this property makes selected-by-default\n        // options in Safari work properly\n        if (elem.parentNode) {\n          elem.parentNode.selectedIndex;\n        }\n\n        return elem.selected === true;\n      },\n      // Contents\n      \"empty\": function (elem) {\n        // http://www.w3.org/TR/selectors/#empty-pseudo\n        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n        //   but not by others (comment: 8; processing instruction: 7; etc.)\n        // nodeType < 6 works because attributes (2) do not appear as children\n        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n          if (elem.nodeType < 6) {\n            return false;\n          }\n        }\n\n        return true;\n      },\n      \"parent\": function (elem) {\n        return !Expr.pseudos[\"empty\"](elem);\n      },\n      // Element/input types\n      \"header\": function (elem) {\n        return rheader.test(elem.nodeName);\n      },\n      \"input\": function (elem) {\n        return rinputs.test(elem.nodeName);\n      },\n      \"button\": function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === \"button\" || name === \"button\";\n      },\n      \"text\": function (elem) {\n        var attr;\n        return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n        // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n        (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n      },\n      // Position-in-collection\n      \"first\": createPositionalPseudo(function () {\n        return [0];\n      }),\n      \"last\": createPositionalPseudo(function (matchIndexes, length) {\n        return [length - 1];\n      }),\n      \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n        return [argument < 0 ? argument + length : argument];\n      }),\n      \"even\": createPositionalPseudo(function (matchIndexes, length) {\n        var i = 0;\n\n        for (; i < length; i += 2) {\n          matchIndexes.push(i);\n        }\n\n        return matchIndexes;\n      }),\n      \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n        var i = 1;\n\n        for (; i < length; i += 2) {\n          matchIndexes.push(i);\n        }\n\n        return matchIndexes;\n      }),\n      \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n        var i = argument < 0 ? argument + length : argument;\n\n        for (; --i >= 0;) {\n          matchIndexes.push(i);\n        }\n\n        return matchIndexes;\n      }),\n      \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n        var i = argument < 0 ? argument + length : argument;\n\n        for (; ++i < length;) {\n          matchIndexes.push(i);\n        }\n\n        return matchIndexes;\n      })\n    }\n  };\n  Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n  for (i in {\n    radio: true,\n    checkbox: true,\n    file: true,\n    password: true,\n    image: true\n  }) {\n    Expr.pseudos[i] = createInputPseudo(i);\n  }\n\n  for (i in {\n    submit: true,\n    reset: true\n  }) {\n    Expr.pseudos[i] = createButtonPseudo(i);\n  } // Easy API for creating new setFilters\n\n\n  function setFilters() {}\n\n  setFilters.prototype = Expr.filters = Expr.pseudos;\n  Expr.setFilters = new setFilters();\n\n  tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n    var matched,\n        match,\n        tokens,\n        type,\n        soFar,\n        groups,\n        preFilters,\n        cached = tokenCache[selector + \" \"];\n\n    if (cached) {\n      return parseOnly ? 0 : cached.slice(0);\n    }\n\n    soFar = selector;\n    groups = [];\n    preFilters = Expr.preFilter;\n\n    while (soFar) {\n      // Comma and first run\n      if (!matched || (match = rcomma.exec(soFar))) {\n        if (match) {\n          // Don't consume trailing commas as valid\n          soFar = soFar.slice(match[0].length) || soFar;\n        }\n\n        groups.push(tokens = []);\n      }\n\n      matched = false; // Combinators\n\n      if (match = rcombinators.exec(soFar)) {\n        matched = match.shift();\n        tokens.push({\n          value: matched,\n          // Cast descendant combinators to space\n          type: match[0].replace(rtrim, \" \")\n        });\n        soFar = soFar.slice(matched.length);\n      } // Filters\n\n\n      for (type in Expr.filter) {\n        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            type: type,\n            matches: match\n          });\n          soFar = soFar.slice(matched.length);\n        }\n      }\n\n      if (!matched) {\n        break;\n      }\n    } // Return the length of the invalid excess\n    // if we're just parsing\n    // Otherwise, throw an error or return tokens\n\n\n    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n    tokenCache(selector, groups).slice(0);\n  };\n\n  function toSelector(tokens) {\n    var i = 0,\n        len = tokens.length,\n        selector = \"\";\n\n    for (; i < len; i++) {\n      selector += tokens[i].value;\n    }\n\n    return selector;\n  }\n\n  function addCombinator(matcher, combinator, base) {\n    var dir = combinator.dir,\n        skip = combinator.next,\n        key = skip || dir,\n        checkNonElements = base && key === \"parentNode\",\n        doneName = done++;\n    return combinator.first ? // Check against closest ancestor/preceding element\n    function (elem, context, xml) {\n      while (elem = elem[dir]) {\n        if (elem.nodeType === 1 || checkNonElements) {\n          return matcher(elem, context, xml);\n        }\n      }\n\n      return false;\n    } : // Check against all ancestor/preceding elements\n    function (elem, context, xml) {\n      var oldCache,\n          uniqueCache,\n          outerCache,\n          newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n      if (xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            if (matcher(elem, context, xml)) {\n              return true;\n            }\n          }\n        }\n      } else {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n            // Defend against cloned attroperties (jQuery gh-1709)\n\n            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n            if (skip && skip === elem.nodeName.toLowerCase()) {\n              elem = elem[dir] || elem;\n            } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n              // Assign to newCache so results back-propagate to previous elements\n              return newCache[2] = oldCache[2];\n            } else {\n              // Reuse newcache so results back-propagate to previous elements\n              uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n              if (newCache[2] = matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n      return false;\n    };\n  }\n\n  function elementMatcher(matchers) {\n    return matchers.length > 1 ? function (elem, context, xml) {\n      var i = matchers.length;\n\n      while (i--) {\n        if (!matchers[i](elem, context, xml)) {\n          return false;\n        }\n      }\n\n      return true;\n    } : matchers[0];\n  }\n\n  function multipleContexts(selector, contexts, results) {\n    var i = 0,\n        len = contexts.length;\n\n    for (; i < len; i++) {\n      Sizzle(selector, contexts[i], results);\n    }\n\n    return results;\n  }\n\n  function condense(unmatched, map, filter, context, xml) {\n    var elem,\n        newUnmatched = [],\n        i = 0,\n        len = unmatched.length,\n        mapped = map != null;\n\n    for (; i < len; i++) {\n      if (elem = unmatched[i]) {\n        if (!filter || filter(elem, context, xml)) {\n          newUnmatched.push(elem);\n\n          if (mapped) {\n            map.push(i);\n          }\n        }\n      }\n    }\n\n    return newUnmatched;\n  }\n\n  function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n    if (postFilter && !postFilter[expando]) {\n      postFilter = setMatcher(postFilter);\n    }\n\n    if (postFinder && !postFinder[expando]) {\n      postFinder = setMatcher(postFinder, postSelector);\n    }\n\n    return markFunction(function (seed, results, context, xml) {\n      var temp,\n          i,\n          elem,\n          preMap = [],\n          postMap = [],\n          preexisting = results.length,\n          // Get initial elements from seed or context\n      elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n          // Prefilter to get matcher input, preserving a map for seed-results synchronization\n      matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n          matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n      postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n      [] : // ...otherwise use results directly\n      results : matcherIn; // Find primary matches\n\n      if (matcher) {\n        matcher(matcherIn, matcherOut, context, xml);\n      } // Apply postFilter\n\n\n      if (postFilter) {\n        temp = condense(matcherOut, postMap);\n        postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n        i = temp.length;\n\n        while (i--) {\n          if (elem = temp[i]) {\n            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n          }\n        }\n      }\n\n      if (seed) {\n        if (postFinder || preFilter) {\n          if (postFinder) {\n            // Get the final matcherOut by condensing this intermediate into postFinder contexts\n            temp = [];\n            i = matcherOut.length;\n\n            while (i--) {\n              if (elem = matcherOut[i]) {\n                // Restore matcherIn since elem is not yet a final match\n                temp.push(matcherIn[i] = elem);\n              }\n            }\n\n            postFinder(null, matcherOut = [], temp, xml);\n          } // Move matched elements from seed to results to keep them synchronized\n\n\n          i = matcherOut.length;\n\n          while (i--) {\n            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n              seed[temp] = !(results[temp] = elem);\n            }\n          }\n        } // Add elements to results, through postFinder if defined\n\n      } else {\n        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n        if (postFinder) {\n          postFinder(null, results, matcherOut, xml);\n        } else {\n          push.apply(results, matcherOut);\n        }\n      }\n    });\n  }\n\n  function matcherFromTokens(tokens) {\n    var checkContext,\n        matcher,\n        j,\n        len = tokens.length,\n        leadingRelative = Expr.relative[tokens[0].type],\n        implicitRelative = leadingRelative || Expr.relative[\" \"],\n        i = leadingRelative ? 1 : 0,\n        // The foundational matcher ensures that elements are reachable from top-level context(s)\n    matchContext = addCombinator(function (elem) {\n      return elem === checkContext;\n    }, implicitRelative, true),\n        matchAnyContext = addCombinator(function (elem) {\n      return indexOf(checkContext, elem) > -1;\n    }, implicitRelative, true),\n        matchers = [function (elem, context, xml) {\n      var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n      checkContext = null;\n      return ret;\n    }];\n\n    for (; i < len; i++) {\n      if (matcher = Expr.relative[tokens[i].type]) {\n        matchers = [addCombinator(elementMatcher(matchers), matcher)];\n      } else {\n        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n        if (matcher[expando]) {\n          // Find the next relative operator (if any) for proper handling\n          j = ++i;\n\n          for (; j < len; j++) {\n            if (Expr.relative[tokens[j].type]) {\n              break;\n            }\n          }\n\n          return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n          tokens.slice(0, i - 1).concat({\n            value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n          })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n        }\n\n        matchers.push(matcher);\n      }\n    }\n\n    return elementMatcher(matchers);\n  }\n\n  function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n    var bySet = setMatchers.length > 0,\n        byElement = elementMatchers.length > 0,\n        superMatcher = function (seed, context, xml, results, outermost) {\n      var elem,\n          j,\n          matcher,\n          matchedCount = 0,\n          i = \"0\",\n          unmatched = seed && [],\n          setMatched = [],\n          contextBackup = outermostContext,\n          // We must always have either seed elements or outermost context\n      elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n          // Use integer dirruns iff this is the outermost matcher\n      dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n          len = elems.length;\n\n      if (outermost) {\n        outermostContext = context === document || context || outermost;\n      } // Add elements passing elementMatchers directly to results\n      // Support: IE<9, Safari\n      // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n      for (; i !== len && (elem = elems[i]) != null; i++) {\n        if (byElement && elem) {\n          j = 0;\n\n          if (!context && elem.ownerDocument !== document) {\n            setDocument(elem);\n            xml = !documentIsHTML;\n          }\n\n          while (matcher = elementMatchers[j++]) {\n            if (matcher(elem, context || document, xml)) {\n              results.push(elem);\n              break;\n            }\n          }\n\n          if (outermost) {\n            dirruns = dirrunsUnique;\n          }\n        } // Track unmatched elements for set filters\n\n\n        if (bySet) {\n          // They will have gone through all possible matchers\n          if (elem = !matcher && elem) {\n            matchedCount--;\n          } // Lengthen the array for every element, matched or not\n\n\n          if (seed) {\n            unmatched.push(elem);\n          }\n        }\n      } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n      // makes the latter nonnegative.\n\n\n      matchedCount += i; // Apply set filters to unmatched elements\n      // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n      // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n      // no element matchers and no seed.\n      // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n      // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n      // numerically zero.\n\n      if (bySet && i !== matchedCount) {\n        j = 0;\n\n        while (matcher = setMatchers[j++]) {\n          matcher(unmatched, setMatched, context, xml);\n        }\n\n        if (seed) {\n          // Reintegrate element matches to eliminate the need for sorting\n          if (matchedCount > 0) {\n            while (i--) {\n              if (!(unmatched[i] || setMatched[i])) {\n                setMatched[i] = pop.call(results);\n              }\n            }\n          } // Discard index placeholder values to get only actual matches\n\n\n          setMatched = condense(setMatched);\n        } // Add matches to results\n\n\n        push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n          Sizzle.uniqueSort(results);\n        }\n      } // Override manipulation of globals by nested matchers\n\n\n      if (outermost) {\n        dirruns = dirrunsUnique;\n        outermostContext = contextBackup;\n      }\n\n      return unmatched;\n    };\n\n    return bySet ? markFunction(superMatcher) : superMatcher;\n  }\n\n  compile = Sizzle.compile = function (selector, match\n  /* Internal Use Only */\n  ) {\n    var i,\n        setMatchers = [],\n        elementMatchers = [],\n        cached = compilerCache[selector + \" \"];\n\n    if (!cached) {\n      // Generate a function of recursive functions that can be used to check each element\n      if (!match) {\n        match = tokenize(selector);\n      }\n\n      i = match.length;\n\n      while (i--) {\n        cached = matcherFromTokens(match[i]);\n\n        if (cached[expando]) {\n          setMatchers.push(cached);\n        } else {\n          elementMatchers.push(cached);\n        }\n      } // Cache the compiled function\n\n\n      cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n      cached.selector = selector;\n    }\n\n    return cached;\n  };\n  /**\n   * A low-level selection function that works with Sizzle's compiled\n   *  selector functions\n   * @param {String|Function} selector A selector or a pre-compiled\n   *  selector function built with Sizzle.compile\n   * @param {Element} context\n   * @param {Array} [results]\n   * @param {Array} [seed] A set of elements to match against\n   */\n\n\n  select = Sizzle.select = function (selector, context, results, seed) {\n    var i,\n        tokens,\n        token,\n        type,\n        find,\n        compiled = typeof selector === \"function\" && selector,\n        match = !seed && tokenize(selector = compiled.selector || selector);\n    results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n    // (the latter of which guarantees us context)\n\n    if (match.length === 1) {\n      // Reduce context if the leading compound selector is an ID\n      tokens = match[0] = match[0].slice(0);\n\n      if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n        context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n        if (!context) {\n          return results; // Precompiled matchers will still verify ancestry, so step up a level\n        } else if (compiled) {\n          context = context.parentNode;\n        }\n\n        selector = selector.slice(tokens.shift().value.length);\n      } // Fetch a seed set for right-to-left matching\n\n\n      i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n      while (i--) {\n        token = tokens[i]; // Abort if we hit a combinator\n\n        if (Expr.relative[type = token.type]) {\n          break;\n        }\n\n        if (find = Expr.find[type]) {\n          // Search, expanding context for leading sibling combinators\n          if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n            // If seed is empty or no tokens remain, we can return early\n            tokens.splice(i, 1);\n            selector = seed.length && toSelector(tokens);\n\n            if (!selector) {\n              push.apply(results, seed);\n              return results;\n            }\n\n            break;\n          }\n        }\n      }\n    } // Compile and execute a filtering function if one is not provided\n    // Provide `match` to avoid retokenization if we modified the selector above\n\n\n    (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n    return results;\n  }; // One-time assignments\n  // Sort stability\n\n\n  support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n  // Always assume duplicates if they aren't passed to the comparison function\n\n  support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n  setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n  // Detached nodes confoundingly follow *each other*\n\n  support.sortDetached = assert(function (el) {\n    // Should return 1, but returns 4 (following)\n    return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n  }); // Support: IE<8\n  // Prevent attribute/property \"interpolation\"\n  // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n  if (!assert(function (el) {\n    el.innerHTML = \"<a href='#'></a>\";\n    return el.firstChild.getAttribute(\"href\") === \"#\";\n  })) {\n    addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n      if (!isXML) {\n        return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n      }\n    });\n  } // Support: IE<9\n  // Use defaultValue in place of getAttribute(\"value\")\n\n\n  if (!support.attributes || !assert(function (el) {\n    el.innerHTML = \"<input/>\";\n    el.firstChild.setAttribute(\"value\", \"\");\n    return el.firstChild.getAttribute(\"value\") === \"\";\n  })) {\n    addHandle(\"value\", function (elem, name, isXML) {\n      if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n        return elem.defaultValue;\n      }\n    });\n  } // Support: IE<9\n  // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n  if (!assert(function (el) {\n    return el.getAttribute(\"disabled\") == null;\n  })) {\n    addHandle(booleans, function (elem, name, isXML) {\n      var val;\n\n      if (!isXML) {\n        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n      }\n    });\n  } // EXPOSE\n\n\n  var _sizzle = window.Sizzle;\n\n  Sizzle.noConflict = function () {\n    if (window.Sizzle === Sizzle) {\n      window.Sizzle = _sizzle;\n    }\n\n    return Sizzle;\n  };\n\n  if (typeof define === \"function\" && define.amd) {\n    define(function () {\n      return Sizzle;\n    }); // Sizzle requires that there be a global window in Common-JS like environments\n  } else if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = Sizzle;\n  } else {\n    window.Sizzle = Sizzle;\n  } // EXPOSE\n\n})(window);","map":{"version":3,"sources":["/home/master/ProjectBootstrap/test_task/src/bower_components/jquery/external/sizzle/dist/sizzle.js"],"names":["window","i","support","Expr","getText","isXML","tokenize","compile","select","outermostContext","sortInput","hasDuplicate","setDocument","document","docElem","documentIsHTML","rbuggyQSA","rbuggyMatches","matches","contains","expando","Date","preferredDoc","dirruns","done","classCache","createCache","tokenCache","compilerCache","sortOrder","a","b","hasOwn","hasOwnProperty","arr","pop","push_native","push","slice","indexOf","list","elem","len","length","booleans","whitespace","identifier","attributes","pseudos","rwhitespace","RegExp","rtrim","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","rinputs","rheader","rnative","rquickExpr","rsibling","runescape","funescape","_","escaped","escapedWhitespace","high","String","fromCharCode","rcssescape","fcssescape","ch","asCodePoint","charCodeAt","toString","unloadHandler","disabledAncestor","addCombinator","disabled","dir","next","apply","call","childNodes","nodeType","e","target","els","j","Sizzle","selector","context","results","seed","m","nid","match","groups","newSelector","newContext","ownerDocument","exec","getElementById","id","getElementsByTagName","getElementsByClassName","qsa","test","nodeName","toLowerCase","getAttribute","replace","setAttribute","toSelector","join","testContext","parentNode","querySelectorAll","qsaError","removeAttribute","keys","cache","key","value","cacheLength","shift","markFunction","fn","assert","el","createElement","removeChild","addHandle","attrs","handler","split","attrHandle","siblingCheck","cur","diff","sourceIndex","nextSibling","createInputPseudo","type","name","createButtonPseudo","createDisabledPseudo","isDisabled","createPositionalPseudo","argument","matchIndexes","documentElement","node","hasCompare","subWindow","doc","defaultView","top","addEventListener","attachEvent","className","appendChild","createComment","getById","getElementsByName","filter","attrId","find","getAttributeNode","elems","tag","tmp","innerHTML","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","unshift","expr","elements","ret","attr","val","undefined","specified","escape","sel","error","msg","Error","uniqueSort","duplicates","detectDuplicates","sortStable","sort","splice","textContent","firstChild","nodeValue","selectors","createPseudo","relative","first","preFilter","excess","unquoted","nodeNameSelector","pattern","operator","check","result","what","last","simple","forward","ofType","xml","uniqueCache","outerCache","nodeIndex","start","parent","useCache","lastChild","uniqueID","pseudo","args","setFilters","idx","matched","matcher","unmatched","text","innerText","lang","elemLang","hash","location","activeElement","hasFocus","href","tabIndex","checked","selected","selectedIndex","radio","checkbox","file","password","image","submit","reset","prototype","filters","parseOnly","tokens","soFar","preFilters","cached","combinator","base","skip","checkNonElements","doneName","oldCache","newCache","elementMatcher","matchers","multipleContexts","contexts","condense","map","newUnmatched","mapped","setMatcher","postFilter","postFinder","postSelector","temp","preMap","postMap","preexisting","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","implicitRelative","matchContext","matchAnyContext","concat","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","dirrunsUnique","Math","random","token","compiled","defaultValue","_sizzle","noConflict","define","amd","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\n// EXPOSE\nvar _sizzle = window.Sizzle;\n\nSizzle.noConflict = function() {\n\tif ( window.Sizzle === Sizzle ) {\n\t\twindow.Sizzle = _sizzle;\n\t}\n\n\treturn Sizzle;\n};\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine(function() { return Sizzle; });\n// Sizzle requires that there be a global window in Common-JS like environments\n} else if ( typeof module !== \"undefined\" && module.exports ) {\n\tmodule.exports = Sizzle;\n} else {\n\twindow.Sizzle = Sizzle;\n}\n// EXPOSE\n\n})( window );\n"]},"metadata":{},"sourceType":"module"}